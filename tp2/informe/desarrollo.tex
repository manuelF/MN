
\section{Desarrollo}

La preparaci\'on del experimento no tuvo grandes dificultades, permitiendo
focalizar los esfuerzos en la b\'usqueda, an\'alisis y mejora de filtros. 
La gran cantidad de variantes de implementaciones encontradas del algoritmo a 
utilizar debido al amplio uso de la DCT para la reducci\'on de ruido en se\~nales, 
sumado a lo aprendido sobre el trabajo con matrices en el Trabajo Pr\'actico 
N\'umero 1 posibilitaron el desarrollo de un experimento limpio y de simple 
ejecuci\'on.

Para un mejor entendimiento del fen\'omeno del ruido en las se\~nales, dividimos
el an\'alisis en distintos casos de ruido. Por ejemplo decidimos tomar al ruido
blanco como un caso de testeo importante debido a la \"falta de patrones\". 

En este trabajo decidimos experimentar con instrucciones del compilador que
permiten ejecutar c\'odigo en paralelo. Esta variante ayuda a bajar tiempos de
corrida con matrices de tama\~o considerable.

\index{Desarrollo!Herramientas}
\subsection{Herramientas}

Para la realizaci\'on de los experimentos se utiliz\'o C++ como lenguaje de
programaci\'on para los algoritmos principales. Esta elecci\'on se apoya en
nuestro conocimiento del lenguaje, la eficiencia que aporta y las estructuras de
datos que proporciona, haciendo simple y clara la implementaci\'on de la
resoluci\'on del problema. Como fue comentado anteriormente, fue utilizada la
directiva ``\#pragma omp parallel'' en ciertas porciones de c\'odigo
paralelizables, con el fin de reducir el tiempo de ejecuci\'on donde es posible.

El an\'alisis de los resultados y el ploteo de los gr\'aficos se realiz\'o
mediante el uso del entorno \href{http://www.gnu.org/software/octave/}{GNU
Octave}, libre y compatible con MATLAB.

El control de los experimentos y las ``recetas'' de las experiencias se ven
reflejadas en scripts de shell que levantan archivos de datos con tests
preprogramdos, ejecutan los algoritmos y luego analizan los resultados,
resumiendolos en output en forma de informaci\'on tabular y gr\'aficos.
La existencia de un Makefile fue clave a la hora de automatizar tareas de
compilaci\'on y corrida de tests.

El informe fue realizado mediante la utilizaci\'on de \href{http://www.latex-project.org/}{LaTeX},
 manteniendo la estructura de informe del Trabajo Pr\'actico N\'umero 1 y
permitiendo expresar estructuras y f\'ormulas matem\'aticas de una forma simple.

\subsection{Desarrollo del experimento de reducci\'on de ruido}

Para reducir el ruido utilizamos tres tipos de filtros: Filtro cero, filtro 
exponencial y filtro promediador. En los tres casos empezamos a filtrar las 
se\~nales desde el 5\% (es decir, no procesamos el 5\% de se\~nales de menor
frecuencia) ya que experimentando encontramos que en ese 5\% se encuentra 
generalmente gran parte de la informaci\'on, y en proporci\'on muy poco ruido.

Esto es sobre todo notorio en se\~nales de audio. La t\'eoria atras de esto es la amplitud
de frecuencias de la acustica humana. Se el rango de audicion humana esta entre los 20Hz
y los 20kHz. Este rango enorme concentra la mayor cantidad de informacion en la parte mas baja,
normalmente inferior a los 4kHz (el rango vocal humano). Por eso consideramos que
si hubiera ruido en este sector y lo intentaramos sacar, es mucho m\'as probable que eliminaramos
informaci\'on crucial del audio. Por eso preferimos tocar lo menos posible ese area,
a riesgo de no extraer los m\'aximos niveles de ruido.

\subsection{Filtro Cero}

En el filtro cero tomamos la se\~nal con el mayor coeficiente (en m\'odulo) y 
eliminamos todas las se\~nales que sean al menos el 50\% de la se\~nal de mayor 
coeficiente en m\'odulo. Esto lo hicimos porque cre\'iamos que las se\~nales con 
coeficientes m\'as altos eran las m\'as ruidosas. El primer filtro que aplicamos 
fue el filtro cero sin descartar el primer 5\% y los resultados no fueron muy 
buenos. Cuando se nos ocurrio agregarle a la implementaci\'on la omisi\'on del 
primer 5\% a la hora de filtrar vimos que los resultados fueron mucho mejores.

\subsection{Filtro Exponencial}


El filtro exponencial mejora al filtro cero evitando la p\'erdida de
informaci\'on proporcionada por la se\~nal.

El m\'etodo aplicado sobre los picos en este caso es el de Exponential Decay
(decaimiento exponencial). En pos de mantener informaci\'on sobre la se\~nal a
la hora de ajustarla la idea es, en este caso, reducir los picos en vez de
llevarlos a cero pero tambi\'en actuar sobre su entorno, reduciendo los puntos
cercanos en menor medida.

El filtro exponencial reemplaza los coeficientes de las se\~nales que son m\'as 
grandes y divide los coeficientes de su entorno por 1.2 elevado a 20 menos 
la distancia a la se\~nal, esto es, si el coeficiente es de la se\~nal n\'umero 
35, entonces dividimos al coeficiente de 35 por 1.2 a la 20, al de 34 y el de 
36 por 1.2 a la 19, y as\'i sucesivamente hasta dividir por 1.2 a la 1.

\subsection{Filtro Promedidador}

El filtro promediador distribuye los coeficientes m\'as grandes 
entre las se\~nales vecinas, es decir, si el coeficiente n\'umero k es muy 
grande, le \"pasa\" parte del coeficiente a los coeficientes $k-2$, $k-1$, $k+1$ y
$k+2$. Para ser exactos, el coeficiente se multiplica por 0.3 y le sumamos a sus 
vecinos inmediatos 0.2 por el coeficiente y a los coeficientes a distancia 2, 0.15 
por el coeficiente.

La idea del filtro promediador surge de la observaci\'on de la aplicaci\'on de
los otros en el caso del ruido blanco. Para poder afrontar casos con ruido en
distintas frecuencias muy distintas al mismo tiempo necesitamos obtener un
contexto mayor en cada punto para saber como manejarlos en relaci\'on con sus
vecinos.

\subsection{Aplicaci\'on de ruido}

Se experiment\'o con 2 clases de ruido en las se\~nales:

\begin{itemize}
	\begin{item} {\bf Ruido senoidal:} Aplica un ruido formado por la suma de la se\~nal
original con la funci\'on seno aplicada en la posici\'on de la muestra
correspondiente, multiplicado por 50, para darle mayor amplitud al resultado de
la funci\'on seno.

	Es decir, para cada muestra de nuestra se\~nal aplicamos ruido del siguiente
modo:

	$$senal_ruidosa[i] = senal_original[i] + 50 * sin(i)$$

  En algunos casos, donde decidimos utilizar valores muy altos en vez de 50
para testear el comportamiento en casos con excesivo ruido, llevandolo a valores
como 1000.
	\end{item}

	\begin{item}
		{\bf Ruido Gaussiano:} Este tipo de ruido, tambi\'en denominado ruido
blanco, consiste en sumar a cada punto de la se\~nal un n\'umero aleatorio
proveniente de una distribuci\'on normal de media $\mu = 0$ y varianza $\sigma=100$. 
Este tipo de ruido es muy frecuente e importante en disciplinas como la radio o television
Modela apropiadamente la interferencia estatica, y es producto de eventos no deterministicos como 
la radiaci\'on de fondo del Big Bang. Consiste en un ruido totalmente aleatorio, 
comprendido en todas las frecuencias.

 	Para cada punto se aplica el ruido de la siguiente manera:

    $$senal_{ruidosa}[i] = senal_{original}[i] + random_{gaussiana}(0, 100)$$

	Si bien la amplitud de los valores de la distribuci\'on aleatoria fueron
cambiados para diferentes experimentos, por defecto tomamos una franja de
valores entre 0 y 10.

	\end{item}
\end{itemize}

\subsection{Pasaje a dos dimensiones}

A la hora de pasar el experimento a 2 dimensiones, utilizando im\'agenes en
escala de grises (para mayor simplicidad), tomamos un approach que result\'o
natural y poco costoso viniendo de un mundo de una sola dimensi\'on y que a
posteriori demostr\'o ser confiable como se mostrar\'a m\'as adelante en los
resultados.

La idea en el paso a dos dimensiones es simple. La idea es aplicar los mismos
filtros implementados en una dimension y volver a aplicarlos para cada fila de
la matriz de la imagen ingresada.

De este modo los algoritmos utilizados durante la primera parte del experimento
fueron utilizados sin necesidad de cambios en esta segunda etapa.

A medida que diferentes experimentos fueron agregados, la observaci\'on de
im\'agenes resultantes fue de gran ayuda para detectar errores de c\'alculo como
as\'i tambi\'en patrones de comportamiento de los filtros.

Detectamos tambi\'en que utilizando esta aproximaci\'on a la extensi\'on a dos
dimensiones por fila, encontramos que los errores m\'as groseros, es decir las
diferencias m\'as notables entre la im\'agen original y la recuperada, se
encuentran en determinadas columnas que var\'ian en cada im\'agen pero se
revelan como franjas verticales.
