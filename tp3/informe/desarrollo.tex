\section{Desarrollo}
La dificultad del desarrollo de este experimento fue un poco m\'as elevada a la de los dos trabajos pr\'acticos anteriores. 

En primer lugar, se decidi\'o hacer primero todo el trabajo pr\'actico en Matlab para obtener una pronta aproximaci\'on a los resultados, siendo el desarrollo ampliamente m\'as comodo que en C++ (dado que la SVD forma parte de la libreria estandar de Matlab). Una vez implementado el TP en Matlab, se procedi\'p a realizar el experimento en C++. El primer problema encontrado a la hora de implementar el experimento en Matlab fue que al calcular la SVD con 60.000 imagenes, se generaba una matriz de $60.000 \times 60.000$ elementos de tipo double, que no entraba en memoria, es por eso que se decidi\'o utilizar s\'olo 40.000 imagenes para el experimento en Matlab.

Luego de desarrollar y contar con el experimento funcionando en Matlab, se empez\'o la programaci\'on del mismo en C++. La primera variaci\'on significativa en la implementaci\'on se refiere al descubrimiento de que no es necesario calcular la SVD, sino s\'olo la matriz $V$, resultando en el c\'alculo de una matriz de $60.000 \times 784$ en vez de una de $60.000 \times 60.000$. A\'un as\'i, consideraciones posteriores sugirieron que 60.000 im\'agenes era un n\'umero por dem\'as excesivo y por lo tanto el experimento pas\'o operar con s\'olo 5.000 imagenes. Al analizar los resultados se corrobor\'o que 5000 im\'agenes conforman una muestra significativa, y por lo tanto se realiz\'o el trabajo pr\'actico usando 5.000 imagenes de entrenamiento y 1.000 imagenes de test.

\subsection{Matriz de Covarianza}
Lo primero que hicimos fue generar la matriz de covarianza con las 5.000 imagenes que tomamos para entrenamiento. Para eso seguimos la f\'ormula del enunciado. Primero generamos la matriz $X$ restandole a cada entrada de la matriz el promedio del pixel que representa (promedio de ese pixel en todas las imagenes) y dividir la matriz por $\sqrt{n-1}$. Despu\'es para calcular la matriz de covarianza, a la que llamamos $Mx$, multiplicamos $X^tX$.

\subsection{Factorizaci\'on QR}
A la hora de calcular la SVD nos dimos cuenta de que s\'olo necesitabamos la matriz $V$, es por eso que en vez de calcular la SVD, calculamos la matriz $V$ utilizando la factorizaci\'on QR de la matriz de covarianza. El m\'etodo que utilizamos para calcular la matriz $V$ fue calcular la factorizaci\'on QR de $Mx$ (la matriz de covarianza) con Householder, y multiplicar luego RQ (es decir, en el orden inverso), hasta que la suma de los elementos debajo de la diagonal principal sumasen menos de 15. La elecci\'on del 15 no fue caprichosa, sino que corrimos el experimento con $10^{-5}$ en lugar de 15 pero converg\'ia a un n\'umero entre 14 y 15 por temas de precisi\'on.

Para calcular la matriz $V$, utilizamos la factorizaci\'on de Householder y la implementamos en $o(n^3)$ siendo $n = 784$. Como nuestro programa tard\'o m\'as de 5 horas en calcular la matriz $V$, generamos un archivo que se llama V.txt, si el archivo no exist\'ia previamente entonces generamos la matriz y la guardamos en el archivo, caso contrario, la leemos del archivo.
