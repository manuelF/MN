\section{Desarrollo}
La dificultad del desarrollo de este experimento fue un poco m\'as elevada a la de los dos 
trabajos pr\'acticos anteriores. 

En primer lugar, se decidi\'o hacer primero todo el trabajo pr\'actico en Matlab para obtener 
una pronta aproximaci\'on a los resultados, siendo el desarrollo ampliamente m\'as comodo que 
en C++ (dado que la SVD forma parte de la libreria estandar de Matlab). Una vez implementado 
el TP en Matlab, se procedi\'p a realizar el experimento en C++. El primer problema encontrado 
a la hora de implementar el experimento en Matlab fue que al calcular la SVD con 60.000 imagenes, 
se generaba una matriz de $60.000 \times 60.000$ elementos de tipo double, que no entraba en
memoria, es por eso que se decidi\'o utilizar s\'olo 40.000 imagenes para el experimento en Matlab.

Luego de desarrollar y contar con el experimento funcionando en Matlab, se empez\'o la programaci\'on
del mismo en C++. La primera variaci\'on significativa en la implementaci\'on se refiere al 
descubrimiento de que no es necesario calcular la SVD, sino s\'olo la matriz $V$, resultando 
en el c\'alculo de una matriz de $60.000 \times 784$ en vez de una de $60.000 \times 60.000$.
A\'un as\'i, consideraciones posteriores sugirieron que 60.000 im\'agenes era un n\'umero por 
dem\'as excesivo y por lo tanto el experimento pas\'o operar con s\'olo 5.000 imagenes. 
Al analizar los resultados se corrobor\'o que 5000 im\'agenes conforman una muestra significativa, 
y por lo tanto se realiz\'o el trabajo pr\'actico usando 5.000 imagenes de entrenamiento y 1.000 imagenes de test.

\subsection{Matriz de Covarianza}
El primer paso consisti\'o en generar la matriz de covarianza con las 5.000 imagenes tomadas como datos 
de entrenamiento. Para eso se utiliz\'o la f\'ormula del enunciado. Se gener\'o la matriz $X$ a trav\'es 
de la sustracci\'on a cada entrada de la matriz del promedio del pixel que representa (promedio de ese 
pixel en todas las imagenes) y la posterior divisi\'on la matriz por $\sqrt{n-1}$. Para calcular la
matriz de covarianza, a la que llamamos $Mx$, se realiz\'o el producto $X^tX$.

\subsection{Factorizaci\'on QR}
A la hora de calcular la SVD se present\'o la idea de que s\'olo es necesaria la matriz $V$, es por 
eso que en vez de calcular la SVD, se procedi\'o a calcular la matriz $V$ utilizando la factorizaci\'on 
QR de la matriz de covarianza. El m\'etodo utilizado para calcular la matriz $V$ fue la factorizaci\'on
QR de $Mx$ (la matriz de covarianza) mediante la aplicaci\'on de transformaciones de Householder, y la
posterior multiplicaci\'on RQ (es decir, en el orden inverso), hasta que la suma de los elementos debajo 
de la diagonal principal suman menos de 15. La elecci\'on del 15 no fue caprichosa, sino que es el 
resultado de la corrida del experimento con $10^{-5}$ en lugar de 15, donde converg\'ia a un n\'umero 
entre 14 y 15 por temas de precisi\'on.

Para calcular la matriz $V$, se utiliz\'o la factorizaci\'on de Householder y la se implement\'o en $O(n^3)$ 
siendo $n = 784$. Como el programa resultante tard\'o m\'as de 5 horas en calcular la matriz $V$, se gener\'o 
el archivo V.txt con esta informaci\'on precalculada, si el archivo no exist\'ia previamente entonces se 
genera la matriz y luego se guarda en el archivo, caso contrario, se realiza la lectura del archivo.
